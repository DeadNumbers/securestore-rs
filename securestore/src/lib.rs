#![feature(nll)]
mod errors;
mod serial;
mod shared;
#[cfg(test)]
mod tests;

use self::shared::{EncryptedBlob, Keys, Vault};
use crate::errors::{Error, ErrorKind};
pub use crate::serial::{BinaryDeserializable, BinarySerializable};
use openssl::rand;
use std::fs::File;
use std::path::{Path, PathBuf};

/// Used to specify where encryption/decryption keys should be loaded from
pub enum KeySource<'a> {
    /// Load the keys from a binary file on-disk
    File(&'a Path),
    /// Derive keys from the specified password
    Password(&'a str),
    /// Automatically generate new keys from a secure RNG
    Generate,
}

/// The primary interface used for interacting with the SecureStore.
pub struct SecretsManager {
    vault: Vault,
    path: PathBuf,
    keys: Keys,
}

impl SecretsManager {
    /// Creates a new vault on-disk at path `path` and loads it in a new
    /// instance of `SecretsManager`.
    pub fn new<P: AsRef<Path>>(path: P, key_source: KeySource) -> Result<Self, Error> {
        let path = path.as_ref();

        let vault = Vault::new();
        Ok(SecretsManager {
            keys: key_source.extract_keys(&vault.iv)?,
            path: PathBuf::from(path),
            vault,
        })
    }

    /// Creates a new instance of `SecretsManager` referencing an existing vault
    /// located on-disk.
    pub fn load<P: AsRef<Path>>(path: P, key_source: KeySource) -> Result<Self, Error> {
        let path = path.as_ref();

        let vault = Vault::from_file(path)?;
        Ok(SecretsManager {
            keys: key_source.extract_keys(&vault.iv)?,
            path: PathBuf::from(path),
            vault,
        })
    }

    /// Saves changes to the underlying vault specified by the path supplied
    /// during construction of this `SecretsManager` instance.
    pub fn save(&self) -> Result<(), Error> {
        self.vault.save(&self.path)
    }

    /// Exports the private key(s) resident in memory to a path on-disk. Note
    /// that in addition to be used to export (existing) keys previously
    /// loaded into the secrets store and (new) keys generated by the
    /// secrets store, it can also be used to export keys (possibly
    /// interactively) derived from passwords to an equivalent
    /// representation on-disk.
    pub fn export_keyfile<P: AsRef<Path>>(&self, path: P) -> Result<(), Error> {
        self.keys.export(path)
    }

    /// Decrypts and gets a single secret from the loaded store. If the secret
    /// cannot be found, returns `Err(ErrorKind::SecretNotFound)`
    pub fn get<T: BinaryDeserializable>(&self, name: &str) -> Result<T, Error> {
        match self.vault.secrets.get(name) {
            None => ErrorKind::SecretNotFound.into(),
            Some(blob) => {
                let decrypted = blob.decrypt(&self.keys)?;
                Ok(T::deserialize(decrypted))
            }
        }
    }

    /// Adds a new secret or replaces an existing secret identified by `name` to
    /// the store.
    pub fn set<T: BinarySerializable>(&mut self, name: &str, value: T) -> () {
        let encrypted = EncryptedBlob::encrypt(&self.keys, &T::serialize(&value));
        self.vault.secrets.insert(name.to_string(), encrypted);
    }
}

impl<'a> KeySource<'a> {
    fn extract_keys(&self, iv: &[u8; shared::IV_SIZE]) -> Result<Keys, Error> {
        match &self {
            KeySource::Generate => {
                let mut buffer = [0u8; shared::KEY_COUNT * shared::KEY_LENGTH];
                rand::rand_bytes(&mut buffer).expect("Key generation failure!");

                Keys::import(&buffer[..])
            }
            KeySource::File(path) => {
                let attr = std::fs::metadata(path)?;
                if attr.len() as usize != shared::KEY_COUNT * shared::KEY_LENGTH {
                    return ErrorKind::InvalidKeyfile.into();
                }

                let file = File::open(path)?;
                Keys::import(&file)
            }
            KeySource::Password(password) => {
                use openssl::hash::MessageDigest;
                use openssl::pkcs5::pbkdf2_hmac;

                let mut key_data = [0u8; shared::KEY_COUNT * shared::KEY_LENGTH];
                pbkdf2_hmac(
                    password.as_bytes(),
                    iv,
                    shared::PBKDF2_ROUNDS,
                    MessageDigest::sha1(),
                    &mut key_data,
                )
                .expect("PBKDF2 key generation failed!");

                Keys::import(&key_data[..])
            }
        }
    }
}
