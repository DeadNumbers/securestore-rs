mod errors;
mod shared;

use self::shared::Vault;
use crate::errors::Error;
use openssl::rand;
use serde_derive::{Deserialize, Serialize};
use std::fs::File;
use std::io::Write;
use std::path::{Path, PathBuf};

/// The primary interface used for interacting with the SecureStore.
pub struct SecretsManager {
    vault: Vault,
    path: PathBuf,

    /// The key used to encrypt the secrets
    encryption_key: Option<[u8; shared::KEY_LENGTH]>,
    /// The key used to generate the HMAC used for authenticated encryption
    hmac_key: Option<[u8; shared::KEY_LENGTH]>,
}

impl SecretsManager {
    /// Creates a new vault on-disk at path `p` and loads it in a new instance
    /// of `SecretsManager`.
    pub fn new<P: AsRef<Path>>(path: P) -> Self {
        let path = path.as_ref();

        let mut encryption_key = [0u8; shared::KEY_LENGTH];
        rand::rand_bytes(&mut encryption_key)
            .expect("Key generation failure!");
        let mut hmac_key = [0u8; shared::KEY_LENGTH];
        rand::rand_bytes(&mut hmac_key)
            .expect("Key generation failure!");

        SecretsManager {
            vault: Vault::new(),
            path: PathBuf::from(path),
            encryption_key: Some(encryption_key),
            hmac_key: Some(hmac_key),
        }
    }

    /// Creates a new instance of `SecretsManager` referencing an existing vault
    /// located on-disk.
    pub fn load<P: AsRef<Path>>(path: P) -> Result<Self, Error> {
        let path = path.as_ref();

        Ok(SecretsManager {
            vault: Vault::from_file(path)?,
            path: PathBuf::from(path),
            encryption_key: None,
            hmac_key: None,
        })
    }

    /// Saves changes to the underlying vault specified by the path supplied during
    /// construction of this `SecretsManager` instance.
    pub fn save(&self) -> Result<(), Error> {
        self.vault.save(&self.path)
    }

    /// Exports the private key(s) resident in memory to a path on-disk. Note that
    /// in addition to be used to export (existing) keys previously loaded into the
    /// secrets store and (new) keys generated by the secrets store, it can also be
    /// used to export keys (possibly interactively) derived from passwords to an
    /// equivalent representation on-disk.
    pub fn export_keys<P: AsRef<Path>>(&self, path: P) -> Result<(), Error> {
        let mut file = File::create(path).map_err(Error::Io)?;

        file.write_all(self.encryption_key.as_ref().unwrap())
            .map_err(Error::Io)?;
        file.write_all(self.hmac_key.as_ref().unwrap())
            .map_err(Error::Io)?;

        Ok(())
    }
}
